
"""多线程同步之Lock"""

"""
    为了保证多个线程能安全地操作共享数据，必须确保一个线程在操作共享数据时，其它线程都不能操作。
    以我们日常生活中上厕所为例，厕所就相当于共享数据，但是厕所一次只能进去一个人。
同时想上厕所的人很多，还没轮到的人全部在厕所外等待，轮到的人可以进去使用厕所，同时会把门锁上，
禁止其他人进入。上完厕所的人把门锁打开，打开厕所门，让后面的人进去。
    同理，一个线程A在操作共享数据前必须先试图获得锁从而给相关代码上锁，线程A获得了锁之后，
锁的状态变为"locked"。如果另外一个线程B试图获得锁，线程B的状态会变为"blocked"并且被添加到锁等待池，
只能等待获得锁的线程A释放锁之后，锁的状态变为"unlocked"，线程调度程序再从锁等待池中
处于状态"blocked"的线程中选择一个来获得锁，获得锁之后该线程的状态变为"running"。
由于只有一把锁，无论有多少个线程，同一时刻最多只有一个线程能获得该锁，这样，就确保了
操作共享数据的相关代码只能由一个线程从头到尾完整地执行，从而确保了多个线程操作共享数据总是安全的。
    《图解Python》
    但是，包含锁的相关代码只能以单线程模式执行，因此效率大大降低了。

    标准库模块threading中提供了一个类对象Lock，用于表示锁，以实现多线程之间的同步。
简单地说，同步就意味着"阻塞和等待"。    
    Lock提供了两个分别用于获得锁和释放锁的方法：
（1）acquire(blocking=True, timeout=-1)
    该方法用于获得锁。
    如果参数blocking被设置为False（此时不能设置参数timeout），表示获得锁失败时当前线程
不会被阻塞。
    如果参数blocking被设置为True，表示获得锁失败时当前线程会被阻塞。参数timeout用于指定
被阻塞的最长秒数，如果在指定的秒数后仍然无法获得锁，则获得锁失败；参数timeout的默认值-1表示
会被一直阻塞，直到获得锁成功。
    获得锁成功时该方法返回True，锁的状态从"unlocked"变为"locked"；获得锁失败时该方法返回False。
（2）release()
    该方法用于释放锁。
    如果锁的状态为"locked"，调用该方法后锁的状态变为"unlocked"；
    如果锁的状态为"unlocked"，调用该方法后抛出异常。
    
    为了保证获得锁的线程用完后一定要释放锁，可以将操作共享数据的相关代码放在try语句块中，
把释放锁的代码放在finally语句块中。

    由于类对象Lock遵守了上下文管理协议，所以可以使用with语句创建一个运行时上下文，当进入
运行时上下文时会自动调用特殊方法__enter__()，当离开运行时上下文时会自动调用特殊方法__exit__()。
又因为在Lock的特殊方法__enter__()和__exit__()中分别调用了方法acquire()和release()，
所以可以使用with语句对代码进行简化。
"""
from threading import Thread, Lock

num = 0

lock = Lock()

def do_sth():
    global num
    for i in range(1000000):
        """
        lock.acquire()
        try:
            num += 1
        finally:
            lock.release()
        """
        with lock:
            num += 1

t1 = Thread(target=do_sth)
t2 = Thread(target=do_sth)

t1.start()
t2.start()

t1.join()
t2.join()

print(num)
