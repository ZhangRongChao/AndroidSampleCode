
"""函数的定义之使用*定义个数可变的位置形参"""

"""
    定义函数时，可能无法事先确定传递的位置实参的个数，在这种情况下，可以在形参前添加一个*，
将形参定义为个数可变的位置形参，从而可以接收0个或任意多个位置实参。这些位置实参会将
个数可变的位置形参初始化为一个元组。
"""
def f(*args):
    print(args)

f()         # ()
f(1)        # (1,)
f(1, 2, 3)  # (1, 2, 3)

"""
    定义函数时，最多只能定义一个个数可变的位置形参。
"""
# def fun(*args1, *args2): # multiple * parameters are not allowed
#     print(args1, args2)

"""
    很多内置函数都定义了个数可变的位置形参。例如，内置函数print()的定义为：
def print(*objects, sep=' ', end='\n', file=sys.stdout, flush=False):
"""
print()
print(1)        # 1
print(1, 2)     # 1 2
print(1, 2, 3)  # 1 2 3

"""
    通常，把个数可变的位置形参定义为最后一个形参，以便接收所有剩余的位置实参。
"""
def fun1(a, b, *c):
    print('a =', a, 'b =', b, 'c =', c)

fun1(1, 2, 3, 4, 5) # a = 1 b = 2 c = (3, 4, 5)
"""
    如果个数可变的位置形参不是最后一个形参，那么其后面的所有形参都被定义为只能接收关键字实参的
关键字形参。如果向这些关键字形参传递位置实参，所有的位置实参都会被算作个数可变的，
从而导致关键字实参的缺失。
"""
def fun2(a, *b, c, d):
    print('a =', a, 'b =', b, 'c =', c, 'd =', d)

fun2(1, 2, 3, 4, c = 5, d = 6) # a = 1 b = (2, 3, 4) c = 5 d = 6

# 可能你想把实参5和6分别传递给形参c和d，但是，
# 2、3、4、5、6全被算作了个数可变的位置实参，从而导致形参c和d对应实参的缺失
# fun2() missing 2 required keyword-only arguments: 'c' and 'd'
# fun2(1, 2, 3, 4, 5, 6)
"""
    《图解Python》
"""
